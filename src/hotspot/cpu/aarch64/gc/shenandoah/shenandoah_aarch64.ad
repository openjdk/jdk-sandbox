//
// Copyright (c) 2018, Red Hat, Inc. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 only, as
// published by the Free Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// You should have received a copy of the GNU General Public License version
// 2 along with this work; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
//
// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
// or visit www.oracle.com if you need additional information or have any
// questions.
//
//

source %{
#include "gc/shenandoah/shenandoahBarrierSet.hpp"
#include "gc/shenandoah/shenandoahBarrierSetAssembler_aarch64.hpp"
#include "gc/shenandoah/c2/shenandoahBarrierSetC2.hpp"
%}

instruct storeP_shenandoah(indirect mem, iRegP src, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set mem (StoreP mem src));
  predicate(UseShenandoahGC && !needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  effect(TEMP tmp, KILL cr);
  ins_cost(INSN_COST);
  format %{ "str  $src, $mem\t# ptr" %}
  ins_encode %{
    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                        $mem$$Register /* addr, used in slow path only */,
                                                        noreg          /*                       */,
                                                        $tmp$$Register /* gc_state on fast path */,
                                                        false           /* encoded_preval */);
    __ str($src$$Register, $mem$$Register);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp$$Register /* tmp */);
  %}
  ins_pipe(istore_reg_mem);
%}

instruct storePVolatile_shenandoah(indirect mem, iRegP src, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set mem (StoreP mem src));
  predicate(UseShenandoahGC && needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  effect(TEMP tmp, KILL cr);
  ins_cost(VOLATILE_REF_COST);
  format %{ "stlr  $src, $mem\t# ptr" %}
  ins_encode %{
    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                        $mem$$Register /* addr, used in slow path only */,
                                                        noreg          /*                                 */,
                                                        $tmp$$Register /* gc_state on fas path */,
                                                        false           /* encoded_preval */);

    __ stlr($src$$Register, $mem$$Register);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp$$Register /* tmp */);
  %}
  ins_pipe(pipe_class_memory);
%}

instruct storeN_shenandoah(indirect mem, iRegN src, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set mem (StoreN mem src));
  predicate(UseShenandoahGC && !needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  effect(TEMP tmp, KILL cr);
  ins_cost(INSN_COST);
  format %{ "strw  $src, $mem\t# compressed ptr" %}
  ins_encode %{
    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                        $mem$$Register /* addr, used in slow path only */,
                                                        noreg /* pre_val, used in slow path only */,
                                                        $tmp$$Register /* gc_state on fas path */,
                                                        false           /* encoded_preval */);

    __ strw($src$$Register, $mem$$Register);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp$$Register /* tmp */);
  %}
  ins_pipe(istore_reg_mem);
%}

instruct storeNVolatile_shenandoah(indirect mem, iRegN src, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set mem (StoreN mem src));
  predicate(UseShenandoahGC && needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  effect(TEMP tmp, KILL cr);
  ins_cost(VOLATILE_REF_COST);
  format %{ "stlrw  $src, $mem\t# compressed ptr" %}
  ins_encode %{
    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                        $mem$$Register /* addr, used in slow path only */,
                                                        noreg          /* pre_val, used in slow path only */,
                                                        $tmp$$Register /* gc_state on fas path */,
                                                        false           /* encoded_preval */);

    __ stlrw($src$$Register, $mem$$Register);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp$$Register /* tmp */);
  %}
  ins_pipe(pipe_class_memory);
%}

instruct encodePAndStoreN_shenandoah(indirect mem, iRegP src, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set mem (StoreN mem (EncodeP src)));
  predicate(UseShenandoahGC && !needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  effect(TEMP tmp, KILL cr);
  ins_cost(INSN_COST);
  format %{ "encode_heap_oop $tmp, $src\n\t"
            "strw  $tmp, $mem\t# compressed ptr" %}
  ins_encode %{
    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                        $mem$$Register /* addr, used in slow path only */,
                                                        noreg /* pre_val, used in slow path only */,
                                                        $tmp$$Register /* gc_state on fas path */,
                                                        false           /* encoded_preval */);

    if ((barrier_data() & ShenandoahBarrierCardMarkNotNull) == 0) {
      __ encode_heap_oop($tmp$$Register, $src$$Register);
    } else {
      __ encode_heap_oop_not_null($tmp$$Register, $src$$Register);
    }

    __ strw($tmp$$Register, $mem$$Register);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp$$Register /* tmp */);
  %}
  ins_pipe(istore_reg_mem);
%}

instruct encodePAndStoreNVolatile_shenandoah(indirect mem, iRegP src, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set mem (StoreN mem (EncodeP src)));
  predicate(UseShenandoahGC && needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  effect(TEMP tmp, KILL cr);
  ins_cost(VOLATILE_REF_COST);
  format %{ "encode_heap_oop $tmp, $src\n\t"
            "stlrw  $tmp, $mem\t# compressed ptr" %}
  ins_encode %{
    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                        $mem$$Register /* addr, used in slow path only */,
                                                        noreg /* pre_val, used in slow path only */,
                                                        $tmp$$Register /* gc_state on fas path */,
                                                        false           /* encoded_preval */);

    if ((barrier_data() & ShenandoahBarrierCardMarkNotNull) == 0) {
      __ encode_heap_oop($tmp$$Register, $src$$Register);
    } else {
      __ encode_heap_oop_not_null($tmp$$Register, $src$$Register);
    }

    __ stlrw($tmp$$Register, $mem$$Register);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp$$Register /* tmp */);
  %}
  ins_pipe(pipe_class_memory);
%}

instruct compareAndSwapP_shenandoah(iRegINoSp res, indirect mem, iRegPNoSp oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)
%{
  match(Set res (CompareAndSwapP mem (Binary oldval newval)));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(2 * VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);
  format %{
    "cmpxchg_shenandoah $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    guarantee(!UseCompressedOops, "must not be compressed oops");

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp1$$Register, gcs_addr);

    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                         noreg             /* addr */,
                                                         $oldval$$Register   /* pre_val, because addr above is noreg this will be readonly always */,
                                                         $tmp1$$Register   /* gc_state */,
                                                         true);
    }

    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm,
                                                        $mem$$base$$Register,
                                                        $oldval$$Register,
                                                        $newval$$Register,
                                                        $res$$Register,
                                                        $tmp1$$Register,    /* gc_state */
                                                        $tmp2$$Register,
                                                        /*acquire*/ false,
                                                        /*release*/ true,
                                                        /*weak*/ false,
                                                        /*is_cae*/ false);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register  /* addr */,
                                                       $tmp1$$Register /* tmp */);
  %}

  ins_pipe(pipe_slow);
%}

instruct compareAndSwapN_shenandoah(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)
%{
  match(Set res (CompareAndSwapN mem (Binary oldval newval)));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(2 * VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);
  format %{
    "cmpxchgw_shenandoah $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    guarantee(UseCompressedOops, "must be compressed oops");

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp1$$Register, gcs_addr);

    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                          noreg             /* addr */,
                                                          $oldval$$Register /* fastpath: unused, slowpath: preval */,
                                                          $tmp1$$Register   /* fastpath: gc_state, slowpath: tmp */,
                                                          true);
    }

    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm,
                                                        $mem$$base$$Register,
                                                        $oldval$$Register,
                                                        $newval$$Register,
                                                        $res$$Register,
                                                        $tmp1$$Register,    /* gc_state */
                                                        $tmp2$$Register,
                                                        /*acquire*/ false,
                                                        /*release*/ true,
                                                        /*weak*/ false,
                                                        /*is_cae*/ false);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp1$$Register /* tmp */);
  %}

  ins_pipe(pipe_slow);
%}

instruct compareAndSwapPAcq_shenandoah(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, iRegINoSp tmp1, iRegINoSp tmp2, rFlagsReg cr)
%{
  match(Set res (CompareAndSwapP mem (Binary oldval newval)));
  predicate(UseShenandoahGC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);
  format %{
    "cmpxchg_acq_shenandoah $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp1$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                        noreg             /* addr */,
                                                        $oldval$$Register /* pre_val, only used in slow path */,
                                                        $tmp1$$Register   /* gc_state */,
                                                        false           /* encoded_preval */);

    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm,
                                                        $mem$$base$$Register,
                                                        $oldval$$Register,
                                                        $newval$$Register,
                                                        $res$$Register,
                                                        $tmp1$$Register,
                                                        $tmp2$$Register,
                                                        /*acquire*/ true,
                                                        /*release*/ true,
                                                        /*weak*/ false,
                                                        /*is_cae*/ false);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp1$$Register /* tmp */);
  %}

  ins_pipe(pipe_slow);
%}

instruct compareAndSwapNAcq_shenandoah(iRegINoSp res, indirect mem, iRegPNoSp oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)
%{
  match(Set res (CompareAndSwapN mem (Binary oldval newval)));
  predicate(UseShenandoahGC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);
  format %{
    "cmpxchgw_acq_shenandoah $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    guarantee(UseCompressedOops, "must be compressed oops");

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp1$$Register, gcs_addr);

    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                          noreg             /* addr */,
                                                          $oldval$$Register /* pre_val, only used in slow path */,
                                                          $tmp1$$Register   /* gc_state */,
                                                          true              /* encoded_preval */);
    }

    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm,
                                                        $mem$$base$$Register,
                                                        $oldval$$Register,
                                                        $newval$$Register,
                                                        $res$$Register,
                                                        $tmp1$$Register,    /* gc_state */
                                                        $tmp2$$Register,
                                                        /*acquire*/ true,
                                                        /*release*/ true,
                                                        /*weak*/ false,
                                                        /*is_cae*/ false);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp1$$Register /* tmp */);
  %}

  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeN_shenandoah(iRegNNoSp res, indirect mem, iRegPNoSp oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)
%{
  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0 && !needs_acquiring_load_exclusive(n));
  ins_cost(2 * VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);
  format %{
    "cmpxchgw_shenandoah $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    __ block_comment("compareAndExchangeN_shenandoah");

    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    guarantee(UseCompressedOops, "must be compressed oops");

    bool maybe_null = (this->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp1$$Register, gcs_addr);

    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                          noreg           /* addr */,
                                                          $oldval$$Register /* pre_val */,
                                                          $tmp1$$Register  /* gc_state */,
                                                          true              /* encoded_preval */);
    }

    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm,
                                                        $mem$$base$$Register,
                                                        $oldval$$Register,
                                                        $newval$$Register,
                                                        $res$$Register,
                                                        $tmp1$$Register,      /* gc_state */
                                                        $tmp2$$Register,
                                                        /*acquire*/ false,
                                                        /*release*/ true,
                                                        /*weak*/ false,
                                                        /*is_cae*/ true);

    ShenandoahBarrierSet::assembler()->load_ref_barrier_c2(this, masm,
                                                           $res$$Register   /* obj */,
                                                           $mem$$Register   /* addr */,
                                                           true             /* narrow */,
                                                           maybe_null,
                                                           $tmp1$$Register /* gc_state */);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp1$$Register /* tmp */);

    __ block_comment("} compareAndExchangeN_shenandoah");
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeP_shenandoah(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)
%{
  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(2 * VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);
  format %{
    "cmpxchg_shenandoah $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");

    bool maybe_null = (this->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp1$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                        noreg             /* addr */,
                                                        $oldval$$Register /* pre_val */,
                                                        $tmp1$$Register   /* gc_state */,
                                                        false           /* encoded_preval */);

    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm,
                                                        $mem$$base$$Register,
                                                        $oldval$$Register,
                                                        $newval$$Register,
                                                        $res$$Register,
                                                        $tmp1$$Register,        /* gc_state */
                                                        $tmp2$$Register,
                                                        /*acquire*/ false,
                                                        /*release*/ true,
                                                        /*weak*/ false,
                                                        /*is_cae*/ true);

    ShenandoahBarrierSet::assembler()->load_ref_barrier_c2(this, masm,
                                                           $res$$Register /* obj */,
                                                           $mem$$Register /* addr */,
                                                           false /* narrow */,
                                                           maybe_null,
                                                           $tmp1$$Register      /* gc_state */);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp1$$Register /* tmp */);
   %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeNAcq_shenandoah(iRegNNoSp res, indirect mem, iRegNNoSp oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)
%{
  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));
  predicate(UseShenandoahGC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);
  format %{
    "cmpxchgw_acq_shenandoah $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    guarantee(UseCompressedOops, "must be compressed oops");

    bool maybe_null = (this->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp1$$Register, gcs_addr);

    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                          noreg           /* addr */,
                                                          $oldval$$Register /* pre_val */,
                                                          $tmp1$$Register /* gc_state */,
                                                          true            /* encoded_preval */);
    }

    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm,
                                                        $mem$$base$$Register,
                                                        $oldval$$Register,
                                                        $newval$$Register,
                                                        $res$$Register,
                                                        $tmp1$$Register,        /* gc_state */
                                                        $tmp2$$Register,
                                                        /*acquire*/ true,
                                                        /*release*/ true,
                                                        /*weak*/ false,
                                                        /*is_cae*/ true);

    ShenandoahBarrierSet::assembler()->load_ref_barrier_c2(this, masm,
                                                           $res$$Register   /* obj */,
                                                           $mem$$Register   /* addr */,
                                                           true             /* narrow */,
                                                           maybe_null,
                                                           $tmp1$$Register  /* gc_state */);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp1$$Register /* tmp */);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangePAcq_shenandoah(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)
%{
  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
  predicate(UseShenandoahGC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);
  format %{
    "cmpxchg_acq_shenandoah $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");

    bool maybe_null = (this->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp1$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                        noreg             /* addr */,
                                                        $oldval$$Register /* pre_val */,
                                                        $tmp1$$Register   /* gc_state */,
                                                        false           /* encoded_preval */);

    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm,
                                                        $mem$$base$$Register,
                                                        $oldval$$Register,
                                                        $newval$$Register,
                                                        $res$$Register,
                                                        $tmp1$$Register,        /* gc_state */
                                                        $tmp2$$Register,
                                                        /*acquire*/ true,
                                                        /*release*/ true,
                                                        /*weak*/ false,
                                                        /*is_cae*/ true);

    ShenandoahBarrierSet::assembler()->load_ref_barrier_c2(this, masm,
                                                           $res$$Register /* obj */,
                                                           $mem$$Register /* addr */,
                                                           false /* narrow */,
                                                           maybe_null,
                                                           $tmp1$$Register          /* gc_state */);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp1$$Register /* tmp */);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapN_shenandoah(iRegINoSp res, indirect mem, iRegNNoSp oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)
%{
  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(2 * VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);
  format %{
    "cmpxchgw_shenandoah $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    guarantee(UseCompressedOops, "must be compressed oops");

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp1$$Register, gcs_addr);

    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                          noreg /* addr */,
                                                          $oldval$$Register /* pre_val */,
                                                          $tmp1$$Register /* gc_state */,
                                                          true              /* encoded_preval */);
    }

    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm,
                                                        $mem$$base$$Register,
                                                        $oldval$$Register,
                                                        $newval$$Register,
                                                        $res$$Register,
                                                        $tmp1$$Register,        /* gc_state */
                                                        $tmp2$$Register,
                                                        /*acquire*/ false,
                                                        /*release*/ true,
                                                        /*weak*/ true,
                                                        /*is_cae*/ false);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp1$$Register /* tmp */);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapP_shenandoah(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, iRegINoSp tmp1, iRegINoSp tmp2, rFlagsReg cr)
%{
  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(2 * VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);
  format %{
    "cmpxchg_shenandoah $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp1$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                        noreg /* addr */,
                                                        $oldval$$Register /* pre_val */,
                                                        $tmp1$$Register   /* gc_state */,
                                                        false           /* encoded_preval */);

    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm,
                                                        $mem$$base$$Register,
                                                        $oldval$$Register,
                                                        $newval$$Register,
                                                        $res$$Register,
                                                        $tmp1$$Register,         /* gc_state */
                                                        $tmp2$$Register,
                                                        /*acquire*/ false,
                                                        /*release*/ true,
                                                        /*weak*/ true,
                                                        /*is_cae*/ false);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp1$$Register /* tmp */);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapNAcq_shenandoah(iRegINoSp res, indirect mem, iRegNNoSp oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)
%{
  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));
  predicate(UseShenandoahGC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);
  format %{
    "cmpxchgw_acq_shenandoah $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    guarantee(UseCompressedOops, "must be compressed oops");

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp1$$Register, gcs_addr);

    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                          noreg /* addr */,
                                                          $oldval$$Register /* pre_val */,
                                                          $tmp1$$Register /* gc_state */,
                                                          true              /* encoded_preval */);
    }

    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm,
                                                        $mem$$base$$Register,
                                                        $oldval$$Register,
                                                        $newval$$Register,
                                                        $res$$Register,
                                                        $tmp1$$Register,          /* gc_state */
                                                        $tmp2$$Register,
                                                        /*acquire*/ true,
                                                        /*release*/ true,
                                                        /*weak*/ true,
                                                        /*is_cae*/ false);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp1$$Register /* tmp */);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapPAcq_shenandoah(iRegINoSp res, indirect mem, iRegPNoSp oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)
%{
  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
  predicate(UseShenandoahGC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);
  format %{
    "cmpxchg_acq_shenandoah $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp1$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                        noreg /* addr */,
                                                        $oldval$$Register /* pre_val */,
                                                        $tmp1$$Register   /* gc_state */,
                                                        false           /* encoded_preval */);

    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm,
                                                        $mem$$base$$Register,
                                                        $oldval$$Register,
                                                        $newval$$Register,
                                                        $res$$Register,
                                                        $tmp1$$Register,
                                                        $tmp2$$Register,
                                                        /*acquire*/ true,
                                                        /*release*/ true,
                                                        /*weak*/ true,
                                                        /*is_cae*/ false);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp1$$Register /* tmp */);
  %}
  ins_pipe(pipe_slow);
%}

instruct getAndSetP_shenandoah(indirect mem, iRegP newval, iRegPNoSp preval, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set preval (GetAndSetP mem newval));
  predicate(UseShenandoahGC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);
  effect(TEMP_DEF preval, TEMP tmp, KILL cr);
  ins_cost(2 * VOLATILE_REF_COST);
  format %{ "atomic_xchg  $preval, $newval, [$mem]" %}
  ins_encode %{
    assert_different_registers($mem$$Register, $newval$$Register);

    bool maybe_null = (this->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);

    __ atomic_xchg($preval$$Register, $newval$$Register, $mem$$Register);

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                        noreg             /* addr */,
                                                        $preval$$Register /* pre_val */,
                                                        $tmp$$Register    /* gc_state */,
                                                        false           /* encoded_preval */);

    ShenandoahBarrierSet::assembler()->load_ref_barrier_c2(this, masm,
                                                           $preval$$Register /* obj */,
                                                           $mem$$Register /* addr */,
                                                           false /* narrow */,
                                                           maybe_null,
                                                           $tmp$$Register   /* gc_state */);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp$$Register /* tmp */);
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndSetPAcq_shenandoah(indirect mem, iRegP newval, iRegPNoSp preval, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set preval (GetAndSetP mem newval));
  predicate(UseShenandoahGC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);
  effect(TEMP_DEF preval, TEMP tmp, KILL cr);
  ins_cost(VOLATILE_REF_COST);
  format %{ "atomic_xchg_acq  $preval, $newval, [$mem]" %}
  ins_encode %{
    assert_different_registers($mem$$Register, $newval$$Register);

    bool maybe_null = (this->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);

    __ atomic_xchgal($preval$$Register, $newval$$Register, $mem$$Register);

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                        noreg /* addr */,
                                                        $preval$$Register /* pre_val */,
                                                        $tmp$$Register,
                                                        false           /* encoded_preval */);

    ShenandoahBarrierSet::assembler()->load_ref_barrier_c2(this, masm,
                                                           $preval$$Register /* obj */,
                                                           $mem$$Register /* addr */,
                                                           false /* narrow */,
                                                           maybe_null,
                                                           $tmp$$Register   /* gc_state */);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp$$Register /* tmp */);
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndSetN_shenandoah(indirect mem, iRegN newval, iRegNNoSp preval, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set preval (GetAndSetN mem newval));
  predicate(UseShenandoahGC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);
  effect(TEMP_DEF preval, TEMP tmp, KILL cr);
  ins_cost(2 * VOLATILE_REF_COST);
  format %{ "atomic_xchgw $preval, $newval, [$mem]" %}
  ins_encode %{
    assert_different_registers($mem$$Register, $newval$$Register);

    bool maybe_null = (this->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);

    __ atomic_xchgw($preval$$Register, $newval$$Register, $mem$$Register);

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                          noreg /* addr */,
                                                          $preval$$Register /* pre_val */,
                                                          $tmp$$Register /* gc_state */,
                                                          true            /* encoded_preval */);
    }

    ShenandoahBarrierSet::assembler()->load_ref_barrier_c2(this, masm,
                                                           $preval$$Register  /* obj */,
                                                           $mem$$Register     /* addr */,
                                                           true               /* narrow */,
                                                           maybe_null,
                                                           $tmp$$Register    /* gc_state */);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp$$Register /* tmp */);
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndSetNAcq_shenandoah(indirect mem, iRegN newval, iRegNNoSp preval, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set preval (GetAndSetN mem newval));
  predicate(UseShenandoahGC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);
  effect(TEMP_DEF preval, TEMP tmp, KILL cr);
  ins_cost(VOLATILE_REF_COST);
  format %{ "atomic_xchgw_acq $preval, $newval, [$mem]" %}
  ins_encode %{
    assert_different_registers($mem$$Register, $newval$$Register);

    bool maybe_null = (this->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);

    __ atomic_xchgalw($preval$$Register, $newval$$Register, $mem$$Register);

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                          noreg /* addr */,
                                                          $preval$$Register /* pre_val */,
                                                          $tmp$$Register /* gc_state */,
                                                          true              /* encoded_preval */);
    }
    ShenandoahBarrierSet::assembler()->load_ref_barrier_c2(this, masm,
                                                           $preval$$Register /* obj */,
                                                           $mem$$Register /* addr */,
                                                           true /* narrow */,
                                                           maybe_null,
                                                           $tmp$$Register /* gc_state */);

    ShenandoahBarrierSet::assembler()->card_barrier_c2(this, masm,
                                                       $mem$$Register /* addr */,
                                                       $tmp$$Register /* tmp */);
  %}
  ins_pipe(pipe_serial);
%}

instruct loadP_shenandoah(iRegPNoSp dst, indirect mem, iRegPNoSp tmp, rFlagsReg cr)
%{
  // This instruction does not need an acquiring counterpart because it is only
  // used for reference loading (Reference::get()).
  match(Set dst (LoadP mem));
  predicate(UseShenandoahGC && !needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);
  effect(TEMP_DEF dst, TEMP tmp, KILL cr);
  ins_cost(4 * INSN_COST);
  format %{ "ldr  $dst, $mem\t# ptr" %}
  ins_encode %{
    bool maybe_null = (this->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);

    __ ldr($dst$$Register, $mem$$Register);

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                        noreg /* addr */,
                                                        $dst$$Register /* pre_val */,
                                                        $tmp$$Register    /* gc_state */,
                                                        false           /* encoded_preval */);

    ShenandoahBarrierSet::assembler()->load_ref_barrier_c2(this, masm,
                                                           $dst$$Register /* obj */,
                                                           $mem$$Register /* addr */,
                                                           false          /* narrow */,
                                                           maybe_null,
                                                           $tmp$$Register   /* gc_state */);
  %}
  ins_pipe(pipe_class_memory);
%}

instruct loadP_volatile_shenandoah(iRegPNoSp dst, indirect mem, iRegPNoSp tmp, rFlagsReg cr)
%{
  // This instruction does not need an acquiring counterpart because it is only
  // used for reference loading (Reference::get()).
  match(Set dst (LoadP mem));
  predicate(UseShenandoahGC && needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);
  effect(TEMP_DEF dst, TEMP tmp, KILL cr);
  ins_cost(4 * INSN_COST);
  format %{ "ldar  $dst, $mem\t# ptr" %}
  ins_encode %{
    bool maybe_null = (this->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);

    __ ldar($dst$$Register, $mem$$Register);

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                         noreg          /* addr */,
                                                         $dst$$Register /* pre_val */,
                                                         $tmp$$Register /* gc_state */,
                                                         false           /* encoded_preval */);

    ShenandoahBarrierSet::assembler()->load_ref_barrier_c2(this, masm,
                                                           $dst$$Register /* obj */,
                                                           $mem$$Register /* addr */,
                                                           false          /* narrow */,
                                                           maybe_null,
                                                           $tmp$$Register /* gc_state */);
  %}
  ins_pipe(pipe_class_memory);
%}

instruct loadN_decodeN_shenandoah(iRegPNoSp dst, indirect mem, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set dst (DecodeN (LoadN mem)));
  predicate(UseShenandoahGC && !needs_acquiring_load(n->in(1)) && n->in(1)->as_Load()->barrier_data() != 0);
  effect(TEMP_DEF dst, TEMP tmp, KILL cr);
  ins_cost(INSN_COST * 2);
  format %{ "ldrw  $dst, $mem\t# decode(load(n))" %}
  ins_encode %{
    bool maybe_null = (this->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);

    // Loads compressed pointer
    __ ldrw($dst$$Register, $mem$$Register);

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                         noreg     /* addr */,
                                                         $dst$$Register    /* pre_val */,
                                                         $tmp$$Register    /* gc_state */,
                                                        true           /* encoded_preval */);
    }

    ShenandoahBarrierSet::assembler()->load_ref_barrier_c2(this, masm,
                                                           $dst$$Register   /* obj */,
                                                           $mem$$Register   /* addr */,
                                                           true             /* narrow */,
                                                           maybe_null,
                                                           $tmp$$Register  /* gc_state */);

    __ decode_heap_oop($dst$$Register, $dst$$Register);
  %}
  ins_pipe(pipe_class_memory);
%}

instruct loadN_shenandoah(iRegNNoSp dst, indirect mem, iRegNNoSp tmp, rFlagsReg cr)
%{
  match(Set dst (LoadN mem));
  predicate(UseShenandoahGC && !needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);
  effect(TEMP_DEF dst, TEMP tmp, KILL cr);
  ins_cost(INSN_COST * 4);
  format %{ "ldrw  $dst, $mem\t# compressed ptr" %}
  ins_encode %{
    assert_different_registers($dst$$Register, $tmp$$Register);
    bool maybe_null = (this->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);

    // Loads compressed pointer
    __ ldrw($dst$$Register, $mem$$Register);

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                         noreg     /* addr */,
                                                         $dst$$Register    /* pre_val, in this case it'll be only used in the slowpath as tmp. */,
                                                         $tmp$$Register    /* gc_state */,
                                                         true           /* encoded_preval */);
    }

    ShenandoahBarrierSet::assembler()->load_ref_barrier_c2(this, masm,
                                                           $dst$$Register  /* obj */,
                                                           $mem$$Register  /* addr */,
                                                           true            /* narrow */,
                                                           maybe_null,
                                                           $tmp$$Register  /* gc_state */);
  %}
  ins_pipe(pipe_class_memory);
%}

instruct loadN_volatile_shenandoah(iRegNNoSp dst, indirect mem, iRegNNoSp tmp, rFlagsReg cr)
%{
  match(Set dst (LoadN mem));
  predicate(UseShenandoahGC && needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);
  effect(TEMP_DEF dst, TEMP tmp, KILL cr);
  ins_cost(INSN_COST * 3);
  format %{ "ldarw  $dst, $mem\t# ptr"
            "decode_heap_oop $dst, $dst"
  %}
  ins_encode %{
    bool maybe_null = (this->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);

    // Loads compressed pointer
    __ ldarw($dst$$Register, $mem$$Register);

    // Loads gc_state
    Address gcs_addr(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
    __ ldrb($tmp$$Register, gcs_addr);

    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      ShenandoahBarrierSet::assembler()->satb_barrier_c2(this, masm,
                                                         noreg            /* obj */,
                                                         $dst$$Register   /* pre_val, in this case it'll be only used in the slowpath as tmp. */,
                                                         $tmp$$Register  /* gc_state */,
                                                         true             /* encoded_preval */);
    }

    ShenandoahBarrierSet::assembler()->load_ref_barrier_c2(this, masm,
                                                           $dst$$Register   /* obj */,
                                                           $mem$$Register   /* addr */,
                                                           true             /* narrow */,
                                                           maybe_null,
                                                           $tmp$$Register  /* gc_state */);
  %}
  ins_pipe(pipe_class_memory);
%}
