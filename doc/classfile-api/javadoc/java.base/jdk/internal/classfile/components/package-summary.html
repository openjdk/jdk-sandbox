<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (21) -->
<title>jdk.internal.classfile.components</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: module: java.base, package: jdk.internal.classfile.components">
<meta name="generator" content="javadoc/PackageWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../script-dir/jquery-ui.min.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="package-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../module-summary.html">Module</a></li>
<li class="nav-bar-cell1-rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html#package">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Package:</p>
<ul>
<li><a href="#package-description">Description</a></li>
<li><a href="#related-package-summary">Related Packages</a></li>
<li><a href="#class-summary">Classes and Interfaces</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Package:&nbsp;</li>
<li><a href="#package-description">Description</a>&nbsp;|&nbsp;</li>
<li><a href="#related-package-summary">Related Packages</a>&nbsp;|&nbsp;</li>
<li><a href="#class-summary">Classes and Interfaces</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<div class="header">
<div class="sub-title"><span class="module-label-in-package">Module</span>&nbsp;<a href="../../../../module-summary.html">java.base</a></div>
<h1 title="Package jdk.internal.classfile.components" class="title">Package jdk.internal.classfile.components</h1>
</div>
<hr>
<div class="package-signature">package <span class="element-name">jdk.internal.classfile.components</span></div>
<section class="package-description" id="package-description">
<div class="block"><h2 id="specific-components-transformations-and-tools-built-on-top-of-the-classfile-api-heading">Specific components, transformations, and tools built on top of the
 Classfile API</h2>

 The <code>jdk.internal.classfile.components</code> package contains specific
 transformation components and utility classes helping to compose very complex
 tasks with minimal effort.

 <h3 id="classprinter-heading"><a href="ClassPrinter.html" title="class in jdk.internal.classfile.components"><code>ClassPrinter</code></a></h3>
 <p>
 <a href="ClassPrinter.html" title="class in jdk.internal.classfile.components"><code>ClassPrinter</code></a> is a helper class providing seamless export of a <a href="../ClassModel.html" title="interface in jdk.internal.classfile"><code>ClassModel</code></a>, <a href="../FieldModel.html" title="interface in jdk.internal.classfile"><code>FieldModel</code></a>,
 <a href="../MethodModel.html" title="interface in jdk.internal.classfile"><code>MethodModel</code></a>, or <a href="../CodeModel.html" title="interface in jdk.internal.classfile"><code>CodeModel</code></a> into human-readable structured text in
 JSON, XML, or YAML format, or into a tree of traversable and printable nodes.
 <p>
 Primary purpose of <a href="ClassPrinter.html" title="class in jdk.internal.classfile.components"><code>ClassPrinter</code></a> is to provide human-readable class
 info for debugging, exception handling and logging purposes. The printed
 class also conforms to a standard format to support automated offline
 processing.
 <p>
 The most frequent use case is to simply print a class:
 
<div class="snippet-container"><button class="copy snippet-copy" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy"></button>
<pre class="snippet"><code class="language-java">ClassPrinter.toJson(classModel, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);
</code></pre>
</div>

 <p>
 <a href="ClassPrinter.html" title="class in jdk.internal.classfile.components"><code>ClassPrinter</code></a> allows to traverse tree of simple printable nodes to
 hook custom printer:
 
<div class="snippet-container"><button class="copy snippet-copy" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy"></button>
<pre class="snippet"><code class="language-java">void customPrint(ClassModel classModel) {
    print(ClassPrinter.toTree(classModel, ClassPrinter.Verbosity.TRACE_ALL));
}

void print(ClassPrinter.Node node) {
    switch (node) {
        case ClassPrinter.MapNode mn -&gt; {
            // print map header
            mn.values().forEach(this::print);
        }
        case ClassPrinter.ListNode ln -&gt; {
            // print list header
            ln.forEach(this::print);
        }
        case ClassPrinter.LeafNode n -&gt; {
            // print leaf node
        }
    }
}
</code></pre>
</div>

 <p>
 Another use case for <a href="ClassPrinter.html" title="class in jdk.internal.classfile.components"><code>ClassPrinter</code></a> is to simplify writing of automated
 tests:
 
<div class="snippet-container"><button class="copy snippet-copy" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy"></button>
<pre class="snippet"><code class="language-java">@Test
void printNodesInTest(ClassModel classModel) {
    var classNode = ClassPrinter.toTree(classModel, ClassPrinter.Verbosity.TRACE_ALL);
    assertContains(classNode, "method name", "myFooMethod");
    assertContains(classNode, "field name", "myBarField");
    assertContains(classNode, "inner class", "MyInnerFooClass");
}

void assertContains(ClassPrinter.Node node, ConstantDesc key, ConstantDesc value) {
    if (!node.walk().anyMatch(n -&gt; n instanceof ClassPrinter.LeafNode ln
                           &amp;&amp; ln.name().equals(key)
                           &amp;&amp; ln.value().equals(value))) {
        node.toYaml(System.out::print);
        throw new AssertionError("expected %s: %s".formatted(key, value));
    }
}
</code></pre>
</div>


 <h3 id="classremapper-heading"><a href="ClassRemapper.html" title="interface in jdk.internal.classfile.components"><code>ClassRemapper</code></a></h3>
 ClassRemapper is a <a href="../ClassTransform.html" title="interface in jdk.internal.classfile"><code>ClassTransform</code></a>, <a href="../FieldTransform.html" title="interface in jdk.internal.classfile"><code>FieldTransform</code></a>, <a href="../MethodTransform.html" title="interface in jdk.internal.classfile"><code>MethodTransform</code></a> and <a href="../CodeTransform.html" title="interface in jdk.internal.classfile"><code>CodeTransform</code></a> deeply re-mapping all class references
 in any form, according to given map or map function.
 <p>
 The re-mapping is applied to superclass, interfaces, all kinds of descriptors
 and signatures, all attributes referencing classes in any form (including all
 types of annotations), and to all instructions referencing to classes.
 <p>
 Primitive types and arrays are never subjects of mapping and are not allowed
 targets of mapping.
 <p>
 Arrays of reference types are always decomposed, mapped as the base reference
 types and composed back to arrays.
 <p>
 Single class remappigng example:
 
<div class="snippet-container"><button class="copy snippet-copy" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy"></button>
<pre class="snippet"><code class="language-java">var classRemapper = ClassRemapper.of(
        Map.of(ClassDesc.of("Foo"), ClassDesc.of("Bar")));

for (var classModel : allMyClasses) {
    byte[] newBytes = classRemapper.remapClass(classModel);

}
</code></pre>
</div>

 <p>
 Remapping of all classes under specific package:
 
<div class="snippet-container"><button class="copy snippet-copy" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy"></button>
<pre class="snippet"><code class="language-java">var classRemapper = ClassRemapper.of(cd -&gt;
        ClassDesc.ofDescriptor(cd.descriptorString().replace("Lcom/oldpackage/", "Lcom/newpackage/")));

for (var classModel : allMyClasses) {
    byte[] newBytes = classRemapper.remapClass(classModel);

}
</code></pre>
</div>


 <h3 id="codelocalsshifter-heading"><a href="CodeLocalsShifter.html" title="interface in jdk.internal.classfile.components"><code>CodeLocalsShifter</code></a></h3>
 <a href="CodeLocalsShifter.html" title="interface in jdk.internal.classfile.components"><code>CodeLocalsShifter</code></a> is a <a href="../CodeTransform.html" title="interface in jdk.internal.classfile"><code>CodeTransform</code></a>
 shifting locals to newly allocated positions to avoid conflicts during code
 injection. Locals pointing to the receiver or to method arguments slots are
 never shifted. All locals pointing beyond the method arguments are re-indexed
 in order of appearance.
 <p>
 Sample of code transformation shifting all locals in all methods:
 
<div class="snippet-container"><button class="copy snippet-copy" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy"></button>
<pre class="snippet"><code class="language-java">byte[] newBytes = classModel.transform((classBuilder, classElement) -&gt; {
        if (classElement instanceof MethodModel method)
            classBuilder.transformMethod(method,
                    MethodTransform.transformingCode(
                            CodeLocalsShifter.of(method.flags(), method.methodTypeSymbol())));
        else
            classBuilder.accept(classElement);
    });
</code></pre>
</div>


 <h3 id="coderelabeler-heading"><a href="CodeRelabeler.html" title="interface in jdk.internal.classfile.components"><code>CodeRelabeler</code></a></h3>
 <a href="CodeRelabeler.html" title="interface in jdk.internal.classfile.components"><code>CodeRelabeler</code></a> is a <a href="../CodeTransform.html" title="interface in jdk.internal.classfile"><code>CodeTransform</code></a>
 replacing all occurences of <a href="../Label.html" title="interface in jdk.internal.classfile"><code>Label</code></a> in the
 transformed code with new instances.
 All <a href="../instruction/LabelTarget.html" title="interface in jdk.internal.classfile.instruction"><code>LabelTarget</code></a> instructions are
 adjusted accordingly.
 Relabeled code graph is identical to the original.
 <p>
 Primary purpose of <a href="CodeRelabeler.html" title="interface in jdk.internal.classfile.components"><code>CodeRelabeler</code></a> is for repeated injections of the
 same code blocks.
 Repeated injection of the same code block must be relabeled, so each instance
 of <a href="../Label.html" title="interface in jdk.internal.classfile"><code>Label</code></a> is bound in the target bytecode
 exactly once.
 <p>
 Sample transformation relabeling all methods:
 
<div class="snippet-container"><button class="copy snippet-copy" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy"></button>
<pre class="snippet"><code class="language-java">byte[] newBytes = classModel.transform(
        ClassTransform.transformingMethodBodies(
                CodeTransform.ofStateful(CodeRelabeler::of)));
</code></pre>
</div>


 <h3 id="class-instrumentation-sample-heading">Class Instrumentation Sample</h3>
 Following snippet is sample composition of <a href="ClassRemapper.html" title="interface in jdk.internal.classfile.components"><code>ClassRemapper</code></a>, <a href="CodeLocalsShifter.html" title="interface in jdk.internal.classfile.components"><code>CodeLocalsShifter</code></a> and <a href="CodeRelabeler.html" title="interface in jdk.internal.classfile.components"><code>CodeRelabeler</code></a> into fully functional class
 instrumenting transformation:
 
<div class="snippet-container"><button class="copy snippet-copy" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../../copy.svg" alt="Copy"></button>
<pre class="snippet"><code class="language-java">byte[] classInstrumentation(ClassModel target, ClassModel instrumentor, Predicate&lt;MethodModel&gt; instrumentedMethodsFilter) {
    var instrumentorCodeMap = instrumentor.methods().stream()
                                          .filter(instrumentedMethodsFilter)
                                          .collect(Collectors.toMap(mm -&gt; mm.methodName().stringValue() + mm.methodType().stringValue(), mm -&gt; mm.code().orElseThrow()));
    var targetFieldNames = target.fields().stream().map(f -&gt; f.fieldName().stringValue()).collect(Collectors.toSet());
    var targetMethods = target.methods().stream().map(m -&gt; m.methodName().stringValue() + m.methodType().stringValue()).collect(Collectors.toSet());
    var instrumentorClassRemapper = ClassRemapper.of(Map.of(instrumentor.thisClass().asSymbol(), target.thisClass().asSymbol()));
    return target.transform(
            ClassTransform.transformingMethods(
                    instrumentedMethodsFilter,
                    (mb, me) -&gt; {
                        if (me instanceof CodeModel targetCodeModel) {
                            var mm = targetCodeModel.parent().get();
                            //instrumented methods code is taken from instrumentor
                            mb.transformCode(instrumentorCodeMap.get(mm.methodName().stringValue() + mm.methodType().stringValue()),
                                    //all references to the instrumentor class are remapped to target class
                                    instrumentorClassRemapper.asCodeTransform()
                                    .andThen((codeBuilder, instrumentorCodeElement) -&gt; {
                                        //all invocations of target methods from instrumentor are inlined
                                        if (instrumentorCodeElement instanceof InvokeInstruction inv
                                            &amp;&amp; target.thisClass().asInternalName().equals(inv.owner().asInternalName())
                                            &amp;&amp; mm.methodName().stringValue().equals(inv.name().stringValue())
                                            &amp;&amp; mm.methodType().stringValue().equals(inv.type().stringValue())) {

                                            //store stacked method parameters into locals
                                            var storeStack = new ArrayDeque&lt;StoreInstruction&gt;();
                                            int slot = 0;
                                            if (!mm.flags().has(AccessFlag.STATIC))
                                                storeStack.push(StoreInstruction.of(TypeKind.ReferenceType, slot++));
                                            for (var pt : mm.methodTypeSymbol().parameterList()) {
                                                var tk = TypeKind.fromDescriptor(pt.descriptorString());
                                                storeStack.push(StoreInstruction.of(tk, slot));
                                                slot += tk.slotSize();
                                            }
                                            storeStack.forEach(codeBuilder::with);

                                            //inlined target locals must be shifted based on the actual instrumentor locals
                                            codeBuilder.block(inlinedBlockBuilder -&gt; inlinedBlockBuilder
                                                    .transform(targetCodeModel, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol())
                                                    .andThen(CodeRelabeler.of())
                                                    .andThen((innerBuilder, shiftedTargetCode) -&gt; {
                                                        //returns must be replaced with jump to the end of the inlined method
                                                        if (shiftedTargetCode instanceof ReturnInstruction)
                                                            innerBuilder.goto_(inlinedBlockBuilder.breakLabel());
                                                        else
                                                            innerBuilder.with(shiftedTargetCode);
                                                    })));
                                        } else
                                            codeBuilder.with(instrumentorCodeElement);
                                    }));
                        } else
                            mb.with(me);
                    })
            .andThen(ClassTransform.endHandler(clb -&gt;
                //remaining instrumentor fields and methods are injected at the end
                clb.transform(instrumentor,
                        ClassTransform.dropping(cle -&gt;
                                !(cle instanceof FieldModel fm
                                        &amp;&amp; !targetFieldNames.contains(fm.fieldName().stringValue()))
                                &amp;&amp; !(cle instanceof MethodModel mm
                                        &amp;&amp; !"&lt;init&gt;".equals(mm.methodName().stringValue())
                                        &amp;&amp; !targetMethods.contains(mm.methodName().stringValue() + mm.methodType().stringValue())))
                        //and instrumentor class references remapped to target class
                        .andThen(instrumentorClassRemapper)))));
}
</code></pre>
</div>
</div>
</section>
<section class="summary">
<ul class="summary-list">
<li>
<div id="related-package-summary">
<div class="caption"><span>Related Packages</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Package</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><a href="../package-summary.html">jdk.internal.classfile</a></div>
<div class="col-last even-row-color">
<div class="block">Classfile parsing, generation, and transformation</div>
</div>
<div class="col-first odd-row-color"><a href="../attribute/package-summary.html">jdk.internal.classfile.attribute</a></div>
<div class="col-last odd-row-color">&nbsp;</div>
<div class="col-first even-row-color"><a href="../constantpool/package-summary.html">jdk.internal.classfile.constantpool</a></div>
<div class="col-last even-row-color">&nbsp;</div>
<div class="col-first odd-row-color"><a href="../instruction/package-summary.html">jdk.internal.classfile.instruction</a></div>
<div class="col-last odd-row-color">&nbsp;</div>
</div>
</div>
</li>
<li>
<div id="class-summary">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="class-summary-tab0" role="tab" aria-selected="true" aria-controls="class-summary.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('class-summary', 'class-summary', 2)" class="active-table-tab">All Classes and Interfaces</button><button id="class-summary-tab1" role="tab" aria-selected="false" aria-controls="class-summary.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('class-summary', 'class-summary-tab1', 2)" class="table-tab">Interfaces</button><button id="class-summary-tab2" role="tab" aria-selected="false" aria-controls="class-summary.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('class-summary', 'class-summary-tab2', 2)" class="table-tab">Classes</button><button id="class-summary-tab3" role="tab" aria-selected="false" aria-controls="class-summary.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('class-summary', 'class-summary-tab3', 2)" class="table-tab">Enum Classes</button><button id="class-summary-tab4" role="tab" aria-selected="false" aria-controls="class-summary.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('class-summary', 'class-summary-tab4', 2)" class="table-tab">Record Classes</button></div>
<div id="class-summary.tabpanel" role="tabpanel">
<div class="summary-table two-column-summary" aria-labelledby="class-summary-tab0">
<div class="table-header col-first">Class</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color class-summary class-summary-tab2"><a href="ClassPrinter.html" title="class in jdk.internal.classfile.components">ClassPrinter</a></div>
<div class="col-last even-row-color class-summary class-summary-tab2">
<div class="block">A printer of classfiles and its elements.</div>
</div>
<div class="col-first odd-row-color class-summary class-summary-tab1"><a href="ClassPrinter.LeafNode.html" title="interface in jdk.internal.classfile.components">ClassPrinter.LeafNode</a></div>
<div class="col-last odd-row-color class-summary class-summary-tab1">
<div class="block">A leaf node holding single printable value.</div>
</div>
<div class="col-first even-row-color class-summary class-summary-tab1"><a href="ClassPrinter.ListNode.html" title="interface in jdk.internal.classfile.components">ClassPrinter.ListNode</a></div>
<div class="col-last even-row-color class-summary class-summary-tab1">
<div class="block">A tree node holding <a href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/util/List.html" title="class or interface in java.util" class="external-link"><code>List</code></a> of nested nodes.</div>
</div>
<div class="col-first odd-row-color class-summary class-summary-tab1"><a href="ClassPrinter.MapNode.html" title="interface in jdk.internal.classfile.components">ClassPrinter.MapNode</a></div>
<div class="col-last odd-row-color class-summary class-summary-tab1">
<div class="block">A tree node holding <a href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/util/Map.html" title="class or interface in java.util" class="external-link"><code>Map</code></a> of nested nodes.</div>
</div>
<div class="col-first even-row-color class-summary class-summary-tab1"><a href="ClassPrinter.Node.html" title="interface in jdk.internal.classfile.components">ClassPrinter.Node</a></div>
<div class="col-last even-row-color class-summary class-summary-tab1">
<div class="block">Named, traversable, and printable node parent.</div>
</div>
<div class="col-first odd-row-color class-summary class-summary-tab3"><a href="ClassPrinter.Verbosity.html" title="enum class in jdk.internal.classfile.components">ClassPrinter.Verbosity</a></div>
<div class="col-last odd-row-color class-summary class-summary-tab3">
<div class="block">Level of detail to print or export.</div>
</div>
<div class="col-first even-row-color class-summary class-summary-tab1"><a href="ClassRemapper.html" title="interface in jdk.internal.classfile.components">ClassRemapper</a></div>
<div class="col-last even-row-color class-summary class-summary-tab1">
<div class="block"><code>ClassRemapper</code> is a <a href="../ClassTransform.html" title="interface in jdk.internal.classfile"><code>ClassTransform</code></a>, <a href="../FieldTransform.html" title="interface in jdk.internal.classfile"><code>FieldTransform</code></a>,
 <a href="../MethodTransform.html" title="interface in jdk.internal.classfile"><code>MethodTransform</code></a> and <a href="../CodeTransform.html" title="interface in jdk.internal.classfile"><code>CodeTransform</code></a>
 deeply re-mapping all class references in any form, according to given map or
 map function.</div>
</div>
<div class="col-first odd-row-color class-summary class-summary-tab4"><a href="ClassRemapper.ClassRemapperImpl.html" title="class in jdk.internal.classfile.components">ClassRemapper.ClassRemapperImpl</a></div>
<div class="col-last odd-row-color class-summary class-summary-tab4">&nbsp;</div>
<div class="col-first even-row-color class-summary class-summary-tab1"><a href="CodeLocalsShifter.html" title="interface in jdk.internal.classfile.components">CodeLocalsShifter</a></div>
<div class="col-last even-row-color class-summary class-summary-tab1">
<div class="block"><a href="CodeLocalsShifter.html" title="interface in jdk.internal.classfile.components"><code>CodeLocalsShifter</code></a> is a <a href="../CodeTransform.html" title="interface in jdk.internal.classfile"><code>CodeTransform</code></a> shifting locals to
 newly allocated positions to avoid conflicts during code injection.</div>
</div>
<div class="col-first odd-row-color class-summary class-summary-tab2"><a href="CodeLocalsShifter.CodeLocalsShifterImpl.html" title="class in jdk.internal.classfile.components">CodeLocalsShifter.CodeLocalsShifterImpl</a></div>
<div class="col-last odd-row-color class-summary class-summary-tab2">&nbsp;</div>
<div class="col-first even-row-color class-summary class-summary-tab1"><a href="CodeRelabeler.html" title="interface in jdk.internal.classfile.components">CodeRelabeler</a></div>
<div class="col-last even-row-color class-summary class-summary-tab1">
<div class="block">A code relabeler is a <a href="../CodeTransform.html" title="interface in jdk.internal.classfile"><code>CodeTransform</code></a> replacing all occurrences
 of <a href="../Label.html" title="interface in jdk.internal.classfile"><code>Label</code></a> in the transformed code with new instances.</div>
</div>
<div class="col-first odd-row-color class-summary class-summary-tab4"><a href="CodeRelabeler.CodeRelabelerImpl.html" title="class in jdk.internal.classfile.components">CodeRelabeler.CodeRelabelerImpl</a></div>
<div class="col-last odd-row-color class-summary class-summary-tab4">&nbsp;</div>
<div class="col-first even-row-color class-summary class-summary-tab1"><a href="CodeStackTracker.html" title="interface in jdk.internal.classfile.components">CodeStackTracker</a></div>
<div class="col-last even-row-color class-summary class-summary-tab1">
<div class="block"><a href="CodeStackTracker.html" title="interface in jdk.internal.classfile.components"><code>CodeStackTracker</code></a> is a <a href="../CodeTransform.html" title="interface in jdk.internal.classfile"><code>CodeTransform</code></a> tracking stack content
 and calculating max stack size.</div>
</div>
<div class="col-first odd-row-color class-summary class-summary-tab2"><a href="CodeStackTracker.CodeStackTrackerImpl.html" title="class in jdk.internal.classfile.components">CodeStackTracker.CodeStackTrackerImpl</a></div>
<div class="col-last odd-row-color class-summary class-summary-tab2">&nbsp;</div>
</div>
</div>
</div>
</li>
</ul>
</section>
</main>
</div>
</div>
</body>
</html>
